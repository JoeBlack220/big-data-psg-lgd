\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{a4paper}
\usepackage{setspace}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{hyperref}
\hypersetup{colorlinks,allcolors=black,urlcolor=blue}

\setenumerate[1]{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}
\setitemize[1]{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}
\setenumerate[2]{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}
\setitemize[2]{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}
\setdescription{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}

\usepackage{graphicx}
\usepackage{fontspec}

\defaultfontfeatures{%
	RawFeature={%
		% +swsh,
		+calt
	}%
}

\setmainfont{EB Garamond}

\usepackage{multicol}

\usepackage[semibold]{sourcecodepro}

\usepackage{xcolor}
\usepackage{minted}
\usemintedstyle{friendly}

\definecolor{bg}{rgb}{0.95,0.95,0.95}
\newcommand{\codeinline}[1]{
	\mintinline[bgcolor=bg, fontsize=\scriptsize]{text}{#1}
}

\newenvironment{console}{% Caution:
	\VerbatimEnvironment
	\begin{minted}[xleftmargin=2em,bgcolor=bg,fontsize=\small]{console}% Do NOT delete these comments
	}% Otherwise there will be error when compiling
	{%
	\end{minted}%
}

%-----------%

\title{NoSQL Proof-of-Concept Proposal}
\author{
	Team name: PSG.LGD \\ \\
	Yichun Yan \\
	Ziwei Jiang \\
	Yifan Li \\
	Weiqi Wang
}
\date{\today}



\begin{document}

\maketitle

\tableofcontents
\clearpage

%-------%

\section{Dota2 Game Replay Analysis}
\subsection{Potential Datasets}
Our team aims at exploring data about a popular and long-lived computer game, Dota2. We will primarily get our data from the following three origins:

\begin{enumerate}
\item \href{https://wiki.teamfortress.com/wiki/WebAPI}{Dota2's official API}
\item \href{https://docs.opendota.com/}{OpenDota API}
\item Valve's Dota2 replay servers
\end{enumerate}

We will get the match results data from Dota2's official API. Also we get the data we need to retrieve a replay from replay servers, then get replays. So basically we will have two different kinds of data for our further analysis, relatively large-scale but coarse-grained match results data, and very fine-grained replays data. Considering the file size of one replay, we decide to only include recent professional games for the replay data. Specifically, we can collect them by the following instructions:

\begin{enumerate}
\item Match Results:
	\begin{itemize}
		\item Use \href{https://wiki.teamfortress.com/wiki/WebAPI/GetMatchHistoryBySequenceNum}{GetMatchHistoryBySequenceNum} API to get the match ids, we will need a a field called \\ \codeinline{start_at_match_seq_num} to specify the starting match sequence number of the results. 
		\item Then  we can extract the last sequence number of the results as the \codeinline{start_at_match_seq_num} for the next call. By doing this iteratively we can enlarge our dataset for our first kind of data.
	\end{itemize}
\item Replays:
	\begin{itemize}
		\item Get the match ids of recent professional games from the first dataset we collect.
		\item Use the those ids via \href{https://docs.opendota.com/#tag/matches}{OpenDota API} to get the information we need \\ (\codeinline{cluster} and \codeinline{replay_salt}) for retrieving replays from Valve's replay server
		\item Constructing links in this format:\\  \codeinline{ http://replay<cluster>.valve.net/570/<match_id>_<replay_salt>.dem.bz2} to get the replays.
	\end{itemize}
\end{enumerate}



\subsection{Datasets Description}

We found the approaches to get those data on a \href{https://dev.dota2.com}{developer's forum of Dota2}. Valve's official document of many APIs is outdated so the forum is the only way for us to understand the resulting data.

The match results data is in JSON format, which contains snapshot information about a game's end, like how much gold one player earned at the end of the match, and also contains some information after a match, like how many players thumbs-up the game.

The JSON file for one match will be between 3KB\textasciitilde 5KB, we planed to collect 1,000,000 matches' results data, which will add up to about 5GB.

The replay data is originally in binary format, but we found an open-source program to parse it into strings. So we will be handling the logs of all the activity happens in a single game. We may further parse this file considering that the file size of one single match and it contains many irrelevant information. The size of one replay's size is between 20MB\textasciitilde 80MB. We plan to collect 1,000 matches' replays, which will add up to about 50GB.



\subsection{Data Preprocessing and Specification}

As the raw data is completely unstructured \codeinline{.dem.bz2} file,
preliminary preprocessing must be done before we store the data in our database.

Firstly, we can decompress the \codeinline{.bz2} file with \codeinline{bzip2},
which will give us a \codeinline{.dem} file:

\begin{console}
$ bzip2 -d data.dem.bz2
\end{console}

Next, we can utilize \href{https://github.com/skadistats/clarity}{clarity},
an open source Dota2 replay parser, to extract useful information from the \codeinline{.dem} file.
Based on our exploration and the \href{https://github.com/skadistats/clarity-examples}{examples}
provided by clarity, the following data will be available:

\begin{itemize}
	% info
	\item Player name, id, team formation and hero choice
	% combatlog
	\item Detailed log of the game, including a hero:
	\begin{itemize}
		\item deals damage to another one
		\item heals another one
		\item receives/loses a buff/debuff
		\item kills another one
		\item uses his ability
		\item uses an item
		\item buys an item
		\item receives/loses some gold
		\item gains some XP
		\item buys back (spending money in order to instantly re-spawn)
	\end{itemize}
	% lifestate
	\item Spawn/death of heros and NPCs
	% matchend
	\item Summary of each player's performance in the whole match, including:
	\begin{itemize}
		\item Final level
		\item Kills
		\item Deaths
		\item Assistance
		\item Gold
		\item Last hit
		\item Deny
	\end{itemize}
\end{itemize}

% --------------------------------------------

% Except for those listed above:

% Run success but hard to find meaning:
% 	dump, dumpbaselines, dumpmana, gameevent, modifiers, particles
%	propertychange, resources, seek, spawngroups, stringtabledump, tick

% Run failed: allchat, livesource, metadata, serializers,

% Unknown:
%   - dtinspector: Seems to provide a GUI interface but I(LYF) run in docker, which raises an exception.
%	- entityrun: No output
%	- matchend: Produced result but also raises exception
%	- tempentities: No output

% --------------------------------------------

The following fields are critical to answering our Business Question, ``???".
They will need to be cleansed and validated.

% --------------------------------------------
\subsection{NoSQL Storage Technology}\\
As we mentioned above, we have two datasets - one is the match results data in JSON format, which is a kind of document that can be encoded using a text-based encoding scheme; the other one is preprocessed replay data. After we parsing those replay data, we can gather useful information from replay data in string format instead of binary format(which is inappropriate for document NoSQL database to store).\\

Therefore, we choose to use MongoDB as our primary NoSQL storage technology.\\

\begin{itemize}
\item \textbf{MongoDB}\\
MongoDB is a popular NoSQL storage device that can store high volume, high velocity, high variety Big Data datasets. It's a document storage device, which make storing semi-structure document-oriented data such as JSON much easier. It is an open source NoSQL database, so we are free to use it.\\

Also, MongoDB support partial update. This will help us aggregate values in future games that we would potentially use.\\

\item \textbf{Docker}\\
In order to combine different needs, programming languages and developing environment of many technologies, we will adopt Docker to our project. Using Docker, we can deploy our application into any environment.\\

Docker is a container technology that provide consistency. It's open source and there are many open source applications that have been made in \href{https://hub.docker.com}{Docker Hub}. Docker Hub provides official or verified images, so it's safe to use.\\

In our project, we will build Dockerfile to let it connect with our project. We will use Scala as programming language, and we will get the match results data from Dota2â€™s official API. MongoDB will be used as database. And then we will put all of this into a Docker container.\\

\item \textbf{AWS(Amazon Web Server)}\\
As we mentioned before, we need 5GB to store JSON file, and we need 50GB to store replay data. In order to have enough capacity to store datasets, we will use AWS(Amazon Web Server) to deploy our project on cloud server. Running Docker on AWS will provide us a open source and free way to build and run distributed application and provide a reliable and easy way to scale out.\\

AWS provides numbers of official ways to deploy docker on AWS, such as Amazon ECS, which is a highly scalable, high-performance container orchestration service to run Docker containers on the AWS cloud. After we package datasets and analytics packages into Docker, we will deploy Docker to Amazon ECS.\\
\end{itemize}


% TODO:
% In order to "Describe fields that are critical for your analysis that will need to be cleansed/validated.",
% I need the Business Question first



%-------%



\end{document}



