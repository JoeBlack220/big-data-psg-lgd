\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{a4paper}
\usepackage{setspace}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{hyperref}
\hypersetup{colorlinks,allcolors=black,urlcolor=blue}

\setenumerate[1]{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}
\setitemize[1]{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}
\setenumerate[2]{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}
\setitemize[2]{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}
\setdescription{itemsep=0pt,partopsep=2pt,parsep=0pt ,topsep=2pt}

\usepackage{graphicx}
\usepackage{fontspec}

\defaultfontfeatures{%
	RawFeature={%
		% +swsh,
		+calt
	}%
}

\setmainfont{EB Garamond}

\usepackage{multicol}

\usepackage[semibold]{sourcecodepro}

\usepackage{xcolor}
\usepackage{minted}
\usemintedstyle{friendly}

\definecolor{bg}{rgb}{0.95,0.95,0.95}
\newcommand{\codeinline}[1]{
	\mintinline[bgcolor=bg, fontsize=\scriptsize]{text}{#1}
}

\newenvironment{console}{% Caution:
	\VerbatimEnvironment
	\begin{minted}[xleftmargin=2em,bgcolor=bg,fontsize=\small]{console}% Do NOT delete these comments
	}% Otherwise there will be error when compiling
	{%
	\end{minted}%
}

%-----------%

\title{NoSQL Proof-of-Concept Proposal}
\author{
	Team name: PSG.LGD \\ \\
	Yichun Yan \\
	Ziwei Jiang \\
	Yifan Li \\
	Weiqi Wang
}
\date{\today}



\begin{document}

\maketitle

\tableofcontents
\clearpage

%-------%

\section{Dota2 Game Replay Analysis}
\subsection{Potential Datasets}
Our team aims at exploring data about a popular and long-lived computer game, Dota2. We will mainly use two datasets:
\begin{enumerate}
\item \href{https://wiki.teamfortress.com/wiki/Replay}{Dota2 replay datase}
\item \href{https://wiki.teamfortress.com/wiki/WebAPI/GetMatchDetails}{Dota2 match result dataset}
\end{enumerate}
The first one is a binary format file which can be executed by Dota2's client to reproduce everything happens in the game, we found that we can some open-source project to parse out the information we want. The second dataset is like the snapshot of the state of important information of each player and the whole game.

\begin{enumerate}
\item Valve's Dota2 replay servers
\item \href{https://wiki.teamfortress.com/wiki/WebAPI}{Valve's official API}
\end{enumerate}

We will get the match results data from Valve's official API. Also we get the data we need to retrieve a replay from replay servers, then get replays. So basically we will have two different kinds of data for our further analysis, relatively large-scale but coarse-grained match results data, and very fine-grained replays data. Considering the file size of one replay, we decide to  include recent professional games and randomly select some public games for the replay data. I will mention how we acquire the data in Datasets Description section.


\subsection{Datasets Description}

Valve, which is the company that develop the game, initially try to provide all the players with easy APIs to access the data of the game, but due to the increasing stress on its data servers, it shut down many of its APIs. At the same time, the documentation seems to be never updated since it's created, which makes it much more difficult for us to collect the data. For example, the API which returns a bunch of the match results given a starting match id is not usable anymore, it now can only return most 50 games now. And the API of the game result used to return a field that can help us construct the URL to download replay of that game. But luckily, we found some hints from the \href{https://dev.dota2.com}{developer's forum of Dota2}. We can use the starting sequence number, which works similarly as the match id, to get a series of game results. And by calling a third party API from OpenDota, we can get the important information to construct the URL to download replays again. The specific steps of gaining our data are as following:

\begin{enumerate}
\item Match Results:
	\begin{itemize}
		\item Use \href{https://wiki.teamfortress.com/wiki/WebAPI/GetMatchHistoryBySequenceNum}{GetMatchHistoryBySequenceNum} API to get the match ids, we will need a a field called \\ \codeinline{start_at_match_seq_num} to specify the starting match sequence number of the results.
		\item Then  we can extract the last sequence number of the results as the \codeinline{start_at_match_seq_num} for the next call. By doing this iteratively we can enlarge our dataset for our first kind of data.
	\end{itemize}
\item Replays:
	\begin{itemize}
		\item Get the match ids of recent professional games from the first dataset we collect.
		\item Use the those ids via \href{https://docs.opendota.com/#tag/matches}{OpenDota API} to get the information we need \\ (\codeinline{cluster} and \codeinline{replay_salt}) for retrieving replays from Valve's replay server
		\item Constructing links in this format:\\  \codeinline{ http://replay<cluster>.valve.net/570/<match_id>_<replay_salt>.dem.bz2} to get the replays.
	\end{itemize}
\end{enumerate}

The match results data is in JSON format, which contains snapshot information about a game's end. This data includes the the overall information of a game's result, like the kills of each team, which side wins, and the lineup of each team. It also includes more specific information of each player, like how many gold does a player earn, how many last hits does one player make and so on. Each JSON document contains about 30 fields, and about 15 of them are nested documents. The JSON file for one match will be between 3KB\textasciitilde 5KB, we planed to collect 10,000,000 matches' results data, which will add up to about 50GB. The 10,000,000 will be the matches in the recent versions, and we will filter the unqualified games, like games with escaped players and games with length shorter than 15 minutes.

The replay data is originally in binary format, but we will use an open-source project to parse it into strings, which is the combat log of the whole game. There are several types of the combat log, like damage, heal, buff, death, ability and so on, we can reproduce the whole game process using those combat log. Since we are using MongoDB, we write write a program to transform the string results from parsing to a JSON format file, then store it to the database. After parsing, we  The size of one replay's size is between 40MB\textasciitilde 80MB. We plan to collect 3,000 matches' replays, which will add up to about 180GB. The 3,000 games will consist of 1,000 most recently professional games, 1,000 randomly chosen qualified public games, and 1,000 randomly chosen qualified ranked games. Public games are standard games but don't influence the MMR of each player, while ranked games are standard games that will influence MMR.



\subsection{Data Preprocessing and Specification}

As the raw data is completely unstructured \codeinline{.dem.bz2} file,
preliminary preprocessing must be done before we store the data in our database.

Firstly, we can decompress the \codeinline{.bz2} file with \codeinline{bzip2},
which will give us a \codeinline{.dem} file:

\begin{console}
$ bzip2 -d data.dem.bz2
\end{console}

Next, we can utilize \href{https://github.com/skadistats/clarity}{clarity},
an open source Dota2 replay parser, to extract useful information from the \codeinline{.dem} file.
Based on our exploration and the \href{https://github.com/skadistats/clarity-examples}{examples}
provided by clarity, the following data will be available:

\begin{itemize}
	% info
	\item Player name, id, team formation and hero choice
	% combatlog
	\item Detailed log of the game, including a hero:
	\begin{itemize}
		\item deals damage to another one
		\item heals another one
		\item receives/loses a buff/debuff
		\item kills another one
		\item uses his ability
		\item uses an item
		\item buys an item
		\item receives/loses some gold
		\item gains some XP
		\item buys back (spending money in order to instantly re-spawn)
	\end{itemize}
	% lifestate
	\item Spawn/death of heros and NPCs
	% matchend
	\item Summary of each player's performance in the whole match, including:
	\begin{itemize}
		\item Final level
		\item Kills
		\item Deaths
		\item Assistance
		\item Gold
		\item Last hit
		\item Deny
	\end{itemize}
\end{itemize}

% --------------------------------------------

% Except for those listed above:

% Run success but hard to find meaning:
% 	dump, dumpbaselines, dumpmana, gameevent, modifiers, particles
%	propertychange, resources, seek, spawngroups, stringtabledump, tick

% Run failed: allchat, livesource, metadata, serializers,

% Unknown:
%   - dtinspector: Seems to provide a GUI interface but I(LYF) run in docker, which raises an exception.
%	- entityrun: No output
%	- matchend: Produced result but also raises exception
%	- tempentities: No output

% --------------------------------------------

The following fields are critical to answering our Business Question, ``???".
They will need to be cleansed and validated.

% TODO:
% In order to "Describe fields that are critical for your analysis that will need to be cleansed/validated.",
% I need the Business Question first



%-------%

% potential challenge:
% 1.download replays from the server can be slow, the links may not work
% 2.Both apis have call limits
% 3.It may be really slow to process a relatively large JSON file of each replay

\end{document}



